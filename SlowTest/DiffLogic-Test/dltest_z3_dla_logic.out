(QF-LIA probe check)
(QF-AUFLIA probe check)
(QF-LRA probe check)
(QF-LIRA probe check)
(ILP probe check)
(QF-NIA probe check)
(QF-NRA probe check)
(NIA probe check)
(NRA probe check)
(NIRA probe check)
(LIA probe check)
(LRA probe check)
(LIRA probe check)
(AF-UFNRA probe check)
	(mk DLA tactic)
	(mk SMT tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun x () Int)
func-decl AST: (declare-fun y () Int)
func-decl AST: (declare-fun %lbl%@2 () Bool)
func-decl AST: (declare-fun %lbl%+3 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 0.86 :after-memory 0.86)
(started "check-sat")
check_sat AST:

(let ((a!1 (=> (< x y) (< (* 2 x) (* 2 y))))
      (a!2 (or %lbl%@2 (=> (<= (* 2 x) (* 2 y)) (<= (* 3 x) (* 3 y))))))
(let ((a!3 (=> (! (and %lbl%+0 true) :lblpos +0)
               (and (! (or %lbl%@1 a!1) :lblneg @1) (=> a!1 (! a!2 :lblneg @2))))))
  (not (=> (! (and %lbl%+3 true) :lblpos +3) a!3))))
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
unsat
	(mk DLA tactic)
	(mk SMT tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun tickleBool (Bool) Bool)
(smt.simplifying :time 0.00 :before-memory 0.66 :after-memory 0.66)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun x () Int)
func-decl AST: (declare-fun y () Int)
func-decl AST: (declare-fun %lbl%+2 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 0.86 :after-memory 0.86)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (! (or %lbl%@1 (= (* x y) (* y x))) :lblneg @1)))
(let ((a!2 (=> (! (and %lbl%+2 true) :lblpos +2)
               (=> (! (and %lbl%+0 true) :lblpos +0) a!1))))
  (not a!2)))
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
unsat
	(mk DLA tactic)
	(mk SMT tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun tickleBool (Bool) Bool)
(smt.simplifying :time 0.00 :before-memory 0.66 :after-memory 0.66)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun x () Int)
func-decl AST: (declare-fun y () Int)
func-decl AST: (declare-fun %lbl%+2 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 0.86 :after-memory 0.86)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (=> (and (< 0 (* x y)) (< (* x y) 10)) (< x 10))))
(let ((a!2 (=> (! (and %lbl%+2 true) :lblpos +2)
               (=> (! (and %lbl%+0 true) :lblpos +0)
                   (! (or %lbl%@1 a!1) :lblneg @1)))))
  (not a!2)))
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.diff_logic: non-diff logic expression (* x y))
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.searching)
(smt.final-check "difference-logic")
(smt.final-check "array")
(smt.final-check "bit-vector")
(smt.final-check "datatype")
(smt.final-check "recfun")
(smt.final-check "datalog")
(smt.final-check "seq")
(smt.final-check "fpa")
(smt.final-check "unknown")
(smt.stats :time 0.00 :before-memory 0.86 :after-memory 0.86)
(combined-solver "solver 2 failed, trying solver1")
(combined-solver "using solver 1")
	(solver_na2as check_sat_core)
(simplifier :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(propagate-values :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(ctx-simplify :num-steps 146)
(ctx-simplify :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(solve_eqs :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(elim-uncnstr :num-exprs 26 :num-asts 214 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 26 :num-asts 211 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(propagate-values :num-exprs 26 :num-asts 211 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(normalize-bounds :num-exprs 26 :num-asts 211 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(solve_eqs :num-exprs 26 :num-asts 211 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.tactic start)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.diff_logic: non-diff logic expression (* x y))
(smt.preprocessing :time 0.00 :before-memory 1.26 :after-memory 1.26)
(smt.searching)
(smt.final-check "difference-logic")
(smt.final-check "array")
(smt.final-check "bit-vector")
(smt.final-check "datatype")
(smt.final-check "recfun")
(smt.final-check "datalog")
(smt.final-check "seq")
(smt.final-check "fpa")
(smt.final-check "unknown")
(smt.stats :time 0.00 :before-memory 1.26 :after-memory 1.26)
(smt :num-exprs 26 :num-asts 211 :time 0.00 :before-memory 0.86 :after-memory 0.91)
(tactic-exception "smt tactic failed to show goal to be sat/unsat (incomplete (theory difference-logic))")
unknown
	(mk DLA tactic)
	(mk SMT tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun tickleBool (Bool) Bool)
(smt.simplifying :time 0.00 :before-memory 0.66 :after-memory 0.66)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun y () Int)
func-decl AST: (declare-fun x () Int)
func-decl AST: (declare-fun %lbl%+2 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 0.86 :after-memory 0.86)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (=> (and (>= y 0) (> (- x y) 0)) (> x 0))))
(let ((a!2 (=> (! (and %lbl%+2 true) :lblpos +2)
               (=> (! (and %lbl%+0 true) :lblpos +0)
                   (! (or %lbl%@1 a!1) :lblneg @1)))))
  (not a!2)))
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.searching)
(smt.stats :time 0.00 :before-memory 0.86 :after-memory 0.86)
unsat
	(mk DLA tactic)
	(mk SMT tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun tickleBool (Bool) Bool)
(smt.simplifying :time 0.00 :before-memory 0.66 :after-memory 0.66)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun x () Int)
func-decl AST: (declare-fun y () Int)
func-decl AST: (declare-fun %lbl%+2 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 0.86 :after-memory 0.86)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (=> (and (> (+ x y) 10) (> y 0)) (> (+ (+ x y) y) 9))))
(let ((a!2 (=> (! (and %lbl%+2 true) :lblpos +2)
               (=> (! (and %lbl%+0 true) :lblpos +0)
                   (! (or %lbl%@1 a!1) :lblneg @1)))))
  (not a!2)))
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.diff_logic: non-diff logic expression (+ x (* 2 y)))
(smt.preprocessing :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.searching)
(smt.final-check "difference-logic")
(smt.final-check "array")
(smt.final-check "bit-vector")
(smt.final-check "datatype")
(smt.final-check "recfun")
(smt.final-check "datalog")
(smt.final-check "seq")
(smt.final-check "fpa")
(smt.final-check "unknown")
(smt.stats :time 0.00 :before-memory 0.86 :after-memory 0.86)
(combined-solver "solver 2 failed, trying solver1")
(combined-solver "using solver 1")
	(solver_na2as check_sat_core)
(simplifier :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(propagate-values :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(ctx-simplify :num-steps 146)
(ctx-simplify :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(solve_eqs :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(elim-uncnstr :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(simplifier :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(propagate-values :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(normalize-bounds :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(solve_eqs :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.86)
(smt.tactic start)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
(smt.simplifying :time 0.00 :before-memory 1.16 :after-memory 1.16)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith to Diff Logic)
(smt.simplifier-start)
(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)
(smt.diff_logic: non-diff logic expression (+ x (* 2 y)))
(smt.preprocessing :time 0.00 :before-memory 1.26 :after-memory 1.26)
(smt.searching)
(smt.final-check "difference-logic")
(smt.final-check "array")
(smt.final-check "bit-vector")
(smt.final-check "datatype")
(smt.final-check "recfun")
(smt.final-check "datalog")
(smt.final-check "seq")
(smt.final-check "fpa")
(smt.final-check "unknown")
(smt.stats :time 0.00 :before-memory 1.26 :after-memory 1.26)
(smt :num-exprs 30 :num-asts 218 :time 0.00 :before-memory 0.86 :after-memory 0.92)
(tactic-exception "smt tactic failed to show goal to be sat/unsat (incomplete (theory difference-logic))")
unknown

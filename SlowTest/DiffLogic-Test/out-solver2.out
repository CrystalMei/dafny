(QF-LIA probe check)
(QF-AUFLIA probe check)
(QF-LRA probe check)
(QF-LIRA probe check)
(ILP probe check)
(QF-NIA probe check)
(QF-NRA probe check)
(NIA probe check)
(NRA probe check)
(NIRA probe check)
(LIA probe check)
(LRA probe check)
(LIRA probe check)
(AF-UFNRA probe check)
	(Quantifier Probe)
	(mk SMT tactic)
	(mk preamble tactic)
	(mk QF_FP tactic)
	(mk SMT tactic)
	(mk QF_NRA tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_FP tactic)
	(mk SMT tactic)
	(mk QF_NRA tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk NRA tactic)
	(mk SMT tactic)
(QF-NRA probe check)
(NRA probe check)
	(mk LIRA tactic)
	(mk LRA tactic)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QSAT tactic)
(LIRA probe check)
	(Quantifier Probe)
	(mk quant preprocessor)
(LIRA probe check)
	(mk QF_NIA tactic)
	(mk QF_NIA SMT solver)
	(mk SMT tactic)
	(mk QF_NIA NLSAT solver)
	(mk QF_NIA SMT solver)
	(mk SMT tactic)
	(mk QF_NIA SAT solver)
	(mk QF_NIA BV solver)
	(mk QF_NIA preamble tactic)
(QF-NIA probe check)
	(mk QF_NRA tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_NRA SAT solver)
	(mk SMT tactic)
(QF-NRA probe check)
	(mk QF_LRA tactic)
	(mk SMT tactic)
(QF-LRA probe check)
	(mk QF_AUFLIA tactic)
	(mk SMT tactic)
(QF-AUFLIA probe check)
	(mk QF-LIA tactic)
	(mk preamble tactic)
	(mk SMT tactic)
	(mk bounded tactic)
	(mk no_cut_smt tactic)
	(mk SMT tactic)
	(mk no_cut_no_relevancy_smt tactic)
	(mk SMT tactic)
	(mk no_cut_smt tactic)
	(mk SMT tactic)
	(mk lia2sat tactic)
	(mk bv2sat tactic)
	(mk-lia2pb-tactic)
	(mk pb tactic)
	(mk bv2sat tactic)
(ILP probe check)
	(mk ilp_model_finder tactic)
	(mk lia2sat tactic)
	(mk bv2sat tactic)
	(mk-lia2pb-tactic)
	(mk no_cut_smt tactic)
	(mk SMT tactic)
	(mk lia2sat tactic)
	(mk bv2sat tactic)
	(mk-lia2pb-tactic)
	(mk no_cut_smt tactic)
	(mk SMT tactic)
(ILP probe check)
(QF-LIA probe check)
	(mk QF_AUFBV tactic)
	(mk QF_AUFBV preamble tactic)
	(mk SMT tactic)
	(mk QF_BV tactic)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_BV preamble tactic)
	(mk QF_BV tactic)
	(mk SMT tactic)
	(mk SMT tactic)
	(mk QF_BV preamble tactic)
	(mk FD tactic)
	(mk FD tactic)
mk_combined_solver...
	(mk SMT solver)
func-decl AST: (declare-fun real_pow (Real Real) Real)
func-decl AST: (declare-fun UOrdering2 (T@U T@U) Bool)
func-decl AST: (declare-fun UOrdering3 (T@T T@U T@U) Bool)
func-decl AST: (declare-fun tickleBool (Bool) Bool)
(smt.simplifying :time 0.00 :before-memory 2.06 :after-memory 2.06)
func-decl AST: (declare-fun Ctor (T@T) Int)
func-decl AST: (declare-fun intType () T@T)
func-decl AST: (declare-fun realType () T@T)
func-decl AST: (declare-fun boolType () T@T)
func-decl AST: (declare-fun rmodeType () T@T)
func-decl AST: (declare-fun stringType () T@T)
func-decl AST: (declare-fun regexType () T@T)
func-decl AST: (declare-fun int_2_U (Int) T@U)
func-decl AST: (declare-fun U_2_int (T@U) Int)
func-decl AST: (declare-fun type (T@U) T@T)
func-decl AST: (declare-fun real_2_U (Real) T@U)
func-decl AST: (declare-fun U_2_real (T@U) Real)
func-decl AST: (declare-fun bool_2_U (Bool) T@U)
func-decl AST: (declare-fun U_2_bool (T@U) Bool)
func-decl AST: (declare-fun rmode_2_U (RoundingMode) T@U)
func-decl AST: (declare-fun U_2_rmode (T@U) RoundingMode)
func-decl AST: (declare-fun string_2_U (String) T@U)
func-decl AST: (declare-fun U_2_string (T@U) String)
func-decl AST: (declare-fun regex_2_U ((RegEx String)) T@U)
func-decl AST: (declare-fun U_2_regex (T@U) (RegEx String))
(smt.simplifying :time 0.00 :before-memory 2.06 :after-memory 2.06)
(smt.simplifying :time 0.00 :before-memory 2.06 :after-memory 2.06)
(smt.simplifying :time 0.00 :before-memory 2.06 :after-memory 2.06)
(smt.simplifying :time 0.00 :before-memory 2.06 :after-memory 2.06)
func-decl AST: (declare-fun %lbl%+0 () Bool)
func-decl AST: (declare-fun %lbl%@1 () Bool)
func-decl AST: (declare-fun |a#0| () Int)
func-decl AST: (declare-fun |b#0| () Int)
func-decl AST: (declare-fun %lbl%+2 () Bool)
func-decl AST: (declare-fun %lbl%+3 () Bool)
func-decl AST: (declare-fun %lbl%+4 () Bool)
func-decl AST: (declare-fun %lbl%+5 () Bool)
func-decl AST: (declare-fun %lbl%+6 () Bool)
	(unknown logic setup)
(smt.collecting-features)
	(setup arith: Old Arith)
	(setup arith: Old Arith - theory_i_arith)
(smt.simplifier-start)

before reduce
asserted formulas:
[HEAD] ==>
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :no-pattern (U_2_int x@@5)
     :no-pattern (U_2_bool x@@5)
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (let ((a!1 (not (and (= (type y) (type x@@6))
                          (= (type z) (type x@@6))
                          (UOrdering2 x@@6 y)
                          (UOrdering2 y z)))))
       (or a!1 (UOrdering2 x@@6 z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)))
         (not (= (type y@@0) (type x@@7))))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
inconsistent: 0

(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.refine-injectivity)
(smt.pattern-inference)
(smt.inferred-patterns :qid bg:subtype-refl
  ((UOrdering2 (:var 0) (:var 0)))
)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)

after reduce
asserted formulas:
[HEAD] ==>
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
inconsistent: 0

after internalize_assertions()...
Logical context:
scope-lvl: 0
base-lvl:  0
search-lvl:  0
inconsistent(): 0
m_asserted_formulas.inconsistent(): 0
#1 := true
#23 := (tickleBool true)
#2 := false
#24 := (tickleBool false)
#28 := 0
#26 := intType
#27 := (Ctor intType)
#29 := (= #27 0)
#32 := 1
#30 := realType
#31 := (Ctor realType)
#33 := (= #31 1)
#37 := 2
#35 := boolType
#36 := (Ctor boolType)
#38 := (= #36 2)
#42 := 3
#40 := rmodeType
#41 := (Ctor rmodeType)
#43 := (= #41 3)
#47 := 4
#45 := stringType
#46 := (Ctor stringType)
#48 := (= #46 4)
#52 := 5
#50 := regexType
#51 := (Ctor regexType)
#53 := (= #51 5)
#55 := (:var 0 Int)
#56 := (int_2_U #55)
#59 := (pattern #56)
#57 := (U_2_int #56)
#58 := (= #57 #55)
#60 := (forall (vars (arg0 Int)) (:pat #59) #58)
#62 := (:var 0 T@U)
#65 := (U_2_int #62)
#69 := (pattern #65)
#66 := (int_2_U #65)
#67 := (= #66 #62)
#63 := (type #62)
#64 := (= #63 intType)
#170 := (not #64)
#171 := (or #170 #67)
#172 := (forall (vars (x T@U)) (:pat #69) #171)
#72 := (type #56)
#73 := (= #72 intType)
#74 := (forall (vars (arg0@@0 Int)) (:pat #59) #73)
#7 := (:var 0 Real)
#76 := (real_2_U #7)
#79 := (pattern #76)
#77 := (U_2_real #76)
#78 := (= #77 #7)
#80 := (forall (vars (arg0@@1 Real)) (:pat #79) #78)
#83 := (U_2_real #62)
#87 := (pattern #83)
#84 := (real_2_U #83)
#85 := (= #84 #62)
#82 := (= #63 realType)
#173 := (not #82)
#174 := (or #173 #85)
#175 := (forall (vars (x@@0 T@U)) (:pat #87) #174)
#90 := (type #76)
#91 := (= #90 realType)
#92 := (forall (vars (arg0@@2 Real)) (:pat #79) #91)
#94 := (:var 0 Bool)
#95 := (bool_2_U #94)
#98 := (pattern #95)
#96 := (U_2_bool #95)
#97 := (= #96 #94)
#99 := (forall (vars (arg0@@3 Bool)) (:pat #98) #97)
#102 := (U_2_bool #62)
#106 := (pattern #102)
#103 := (bool_2_U #102)
#104 := (= #103 #62)
#101 := (= #63 boolType)
#176 := (not #101)
#177 := (or #176 #104)
#178 := (forall (vars (x@@1 T@U)) (:pat #106) #177)
#109 := (type #95)
#110 := (= #109 boolType)
#111 := (forall (vars (arg0@@4 Bool)) (:pat #98) #110)
#113 := (:var 0 RoundingMode)
#114 := (rmode_2_U #113)
#117 := (pattern #114)
#115 := (U_2_rmode #114)
#116 := (= #115 #113)
#118 := (forall (vars (arg0@@5 RoundingMode)) (:pat #117) #116)
#121 := (U_2_rmode #62)
#125 := (pattern #121)
#122 := (rmode_2_U #121)
#123 := (= #122 #62)
#120 := (= #63 rmodeType)
#179 := (not #120)
#180 := (or #179 #123)
#181 := (forall (vars (x@@2 T@U)) (:pat #125) #180)
#128 := (type #114)
#129 := (= #128 rmodeType)
#130 := (forall (vars (arg0@@6 RoundingMode)) (:pat #117) #129)
#132 := (:var 0 String[bv[8]])
#133 := (string_2_U #132)
#136 := (pattern #133)
#134 := (U_2_string #133)
#135 := (= #134 #132)
#137 := (forall (vars (arg0@@7 String[bv[8]])) (:pat #136) #135)
#140 := (U_2_string #62)
#144 := (pattern #140)
#141 := (string_2_U #140)
#142 := (= #141 #62)
#139 := (= #63 stringType)
#182 := (not #139)
#183 := (or #182 #142)
#184 := (forall (vars (x@@3 T@U)) (:pat #144) #183)
#147 := (type #133)
#148 := (= #147 stringType)
#149 := (forall (vars (arg0@@8 String[bv[8]])) (:pat #136) #148)
#151 := (:var 0 RegEx[String[bv[8]]])
#152 := (regex_2_U #151)
#155 := (pattern #152)
#153 := (U_2_regex #152)
#154 := (= #153 #151)
#156 := (forall (vars (arg0@@9 RegEx[String[bv[8]]])) (:pat #155) #154)
#159 := (U_2_regex #62)
#163 := (pattern #159)
#160 := (regex_2_U #159)
#161 := (= #160 #62)
#158 := (= #63 regexType)
#185 := (not #158)
#186 := (or #185 #161)
#187 := (forall (vars (x@@4 T@U)) (:pat #163) #186)
#166 := (type #152)
#167 := (= #166 regexType)
#168 := (forall (vars (arg0@@10 RegEx[String[bv[8]]])) (:pat #155) #167)
#188 := (UOrdering2 #62 #62)
#217 := (pattern #188)
#220 := (forall (vars (x@@5 T@U)) (:pat #217) #188)
#191 := (:var 1 T@U)
#198 := (UOrdering2 #191 #62)
#190 := (:var 2 T@U)
#197 := (UOrdering2 #190 #191)
#203 := (pattern #197 #198)
#224 := (not #198)
#223 := (not #197)
#192 := (type #190)
#195 := (= #63 #192)
#222 := (not #195)
#193 := (type #191)
#194 := (= #193 #192)
#221 := (not #194)
#201 := (UOrdering2 #190 #62)
#226 := (or #201 #221 #222 #223 #224)
#225 := (forall (vars (x@@6 T@U) (y T@U) (z T@U)) (:pat #203) #226)
#210 := (UOrdering2 #62 #191)
#215 := (pattern #198 #210)
#227 := (not #210)
#209 := (= #63 #193)
#219 := (not #209)
#212 := (= #191 #62)
#230 := (or #212 #219 #224 #227)
#231 := (forall (vars (x@@7 T@U) (y@@0 T@U)) (:pat #215) #230)
asserted formulas:
#23 #24 #29 #33 #38 #43 #48 #53 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 
current assignment:
#23: (tickleBool true)
#24: (tickleBool false)
#29: (= (Ctor intType) 0)
#33: (= (Ctor realType) 1)
#38: (= (Ctor boolType) 2)
#43: (= (Ctor rmodeType) 3)
#48: (= (Ctor stringType) 4)
#53: (= (Ctor regexType) 5)
#60: #60
#172: #172
#74: #74
#80: #80
#175: #175
#92: #92
#99: #99
#178: #178
#111: #111
#118: #118
#181: #181
#130: #130
#137: #137
#184: #184
#149: #149
#156: #156
#187: #187
#168: #168
#220: #220
#225: #225
#231: #231
expression -> bool_var:
(#1 -> true) (#23 -> p1) (#24 -> p2) (#29 -> p3) (#33 -> p4) (#38 -> p5) (#43 -> p6) (#48 -> p7) (#53 -> p8) (#60 -> p9) (#172 -> p10) (#74 -> p11) (#80 -> p12) (#175 -> p13) (#92 -> p14) (#99 -> p15) (#178 -> p16) (#111 -> p17) (#118 -> p18) (#181 -> p19) (#130 -> p20) (#137 -> p21) (#184 -> p22) (#149 -> p23) (#156 -> p24) (#187 -> p25) (#168 -> p26) (#220 -> p27) (#225 -> p28) (#231 -> p29) 
expression -> enode:
(#1 -> e!0) (#2 -> e!1) (#23 -> e!2) (#24 -> e!3) (#26 -> e!4) (#27 -> e!5) (#28 -> e!6) (#29 -> e!7) (#30 -> e!8) (#31 -> e!9) (#32 -> e!10) (#33 -> e!11) (#35 -> e!12) (#36 -> e!13) (#37 -> e!14) (#38 -> e!15) (#40 -> e!16) (#41 -> e!17) (#42 -> e!18) (#43 -> e!19) (#45 -> e!20) (#46 -> e!21) (#47 -> e!22) (#48 -> e!23) (#50 -> e!24) (#51 -> e!25) (#52 -> e!26) (#53 -> e!27) 
relevant exprs:
#23 #1 #24 #2 #29 #28 #27 #26 #33 #32 #31 #30 #38 #37 #36 #35 #43 #42 #41 #40 #48 #47 #46 #45 #53 #52 #51 #50 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 
	Theory Display
5
Theory arithmetic:
vars:
infeasibles = 0 int_inf = 0
v0    #28   lo:         0, up:         0, value:          0, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 0
v1    #32   lo:         1, up:         1, value:          1, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 1
v2    #37   lo:         2, up:         2, value:          2, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 2
v3    #42   lo:         3, up:         3, value:          3, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 3
v4    #47   lo:         4, up:         4, value:          4, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 4
v5    #52   lo:         5, up:         5, value:          5, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 5
rows (compact view):
rows (expanded view):
atoms:
asserted atoms:
8
7
6
9
recfun
disabled guards:

13
10
12
11
decl2enodes:
id 138 -> #23 #24
id 139 -> #27 #31 #36 #41 #46 #51
hot bool vars:

(smt.preprocessing :time 0.07 :before-memory 2.16 :after-memory 2.16)
(smt.simplifier-start)
(smt.simplifying :time 0.00 :before-memory 2.16 :after-memory 2.16)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (forall ((arg0 Int))
             (! (= (U_2_int (int_2_U arg0)) arg0)
                :pattern ((int_2_U arg0))
                :qid |typeInv:U_2_int|)))
      (a!2 (forall ((x T@U))
             (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
                :pattern ((U_2_int x))
                :qid |cast:U_2_int|)))
      (a!3 (forall ((arg0@@0 Int))
             (! (= (type (int_2_U arg0@@0)) intType)
                :pattern ((int_2_U arg0@@0))
                :qid |funType:int_2_U|)))
      (a!4 (forall ((arg0@@1 Real))
             (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
                :pattern ((real_2_U arg0@@1))
                :qid |typeInv:U_2_real|)))
      (a!5 (forall ((x@@0 T@U))
             (! (=> (= (type x@@0) realType)
                    (= (real_2_U (U_2_real x@@0)) x@@0))
                :pattern ((U_2_real x@@0))
                :qid |cast:U_2_real|)))
      (a!6 (forall ((arg0@@2 Real))
             (! (= (type (real_2_U arg0@@2)) realType)
                :pattern ((real_2_U arg0@@2))
                :qid |funType:real_2_U|)))
      (a!7 (forall ((arg0@@3 Bool))
             (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
                :pattern ((bool_2_U arg0@@3))
                :qid |typeInv:U_2_bool|)))
      (a!8 (forall ((x@@1 T@U))
             (! (=> (= (type x@@1) boolType)
                    (= (bool_2_U (U_2_bool x@@1)) x@@1))
                :pattern ((U_2_bool x@@1))
                :qid |cast:U_2_bool|)))
      (a!9 (forall ((arg0@@4 Bool))
             (! (= (type (bool_2_U arg0@@4)) boolType)
                :pattern ((bool_2_U arg0@@4))
                :qid |funType:bool_2_U|)))
      (a!10 (forall ((arg0@@5 RoundingMode))
              (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
                 :pattern ((rmode_2_U arg0@@5))
                 :qid |typeInv:U_2_rmode|)))
      (a!11 (forall ((x@@2 T@U))
              (! (=> (= (type x@@2) rmodeType)
                     (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
                 :pattern ((U_2_rmode x@@2))
                 :qid |cast:U_2_rmode|)))
      (a!12 (forall ((arg0@@6 RoundingMode))
              (! (= (type (rmode_2_U arg0@@6)) rmodeType)
                 :pattern ((rmode_2_U arg0@@6))
                 :qid |funType:rmode_2_U|)))
      (a!13 (forall ((arg0@@7 String))
              (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
                 :pattern ((string_2_U arg0@@7))
                 :qid |typeInv:U_2_string|)))
      (a!14 (forall ((x@@3 T@U))
              (! (=> (= (type x@@3) stringType)
                     (= (string_2_U (U_2_string x@@3)) x@@3))
                 :pattern ((U_2_string x@@3))
                 :qid |cast:U_2_string|)))
      (a!15 (forall ((arg0@@8 String))
              (! (= (type (string_2_U arg0@@8)) stringType)
                 :pattern ((string_2_U arg0@@8))
                 :qid |funType:string_2_U|)))
      (a!16 (forall ((arg0@@9 (RegEx String)))
              (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
                 :pattern ((regex_2_U arg0@@9))
                 :qid |typeInv:U_2_regex|)))
      (a!17 (forall ((x@@4 T@U))
              (! (=> (= (type x@@4) regexType)
                     (= (regex_2_U (U_2_regex x@@4)) x@@4))
                 :pattern ((U_2_regex x@@4))
                 :qid |cast:U_2_regex|)))
      (a!18 (forall ((arg0@@10 (RegEx String)))
              (! (= (type (regex_2_U arg0@@10)) regexType)
                 :pattern ((regex_2_U arg0@@10))
                 :qid |funType:regex_2_U|))))
  (and (= (Ctor intType) 0)
       (= (Ctor realType) 1)
       (= (Ctor boolType) 2)
       (= (Ctor rmodeType) 3)
       (= (Ctor stringType) 4)
       (= (Ctor regexType) 5)
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       a!9
       a!10
       a!11
       a!12
       a!13
       a!14
       a!15
       a!16
       a!17
       a!18))

(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :no-pattern (U_2_int x@@5)
     :no-pattern (U_2_bool x@@5)
     :qid |bg:subtype-refl|))

(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (=> (and (= (type y) (type x@@6))
              (= (type z) (type x@@6))
              (UOrdering2 x@@6 y)
              (UOrdering2 y z))
         (UOrdering2 x@@6 z))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))

(forall ((x@@7 T@U) (y@@0 T@U))
  (! (=> (= (type y@@0) (type x@@7))
         (=> (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)) (= x@@7 y@@0)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))

(let ((a!1 (or %lbl%@1
               (=> (and (= |a#0| 10) (= |b#0| 11)) (= (+ |a#0| |b#0|) 21)))))
(let ((a!2 (=> (and (= |a#0| 10) (= |b#0| 11))
               (=> (! (and %lbl%+0 true) :lblpos +0) (! a!1 :lblneg @1))))
      (a!3 (=> (not (and (= |a#0| 10) (= |b#0| 11)))
               (=> (! (and %lbl%+0 true) :lblpos +0) (! a!1 :lblneg @1)))))
(let ((a!4 (and (=> (! (and %lbl%+3 true) :lblpos +3) a!2)
                (=> (! (and %lbl%+2 true) :lblpos +2) a!3))))
(let ((a!5 (=> (! (and %lbl%+4 true) :lblpos +4) (=> (not (= |a#0| 10)) a!4))))
(let ((a!6 (and (=> (! (and %lbl%+5 true) :lblpos +5) (=> (= |a#0| 10) a!4))
                a!5)))
  (not (=> (! (and %lbl%+6 true) :lblpos +6) a!6)))))))

	(call solver...)
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)

solver check_sat_core
(declare-sort T@U 0)
(declare-sort T@T 0)
(declare-fun tickleBool (Bool) Bool)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun UOrdering2 (T@U T@U) Bool)
(declare-fun %lbl%+6 () Bool)
(declare-fun %lbl%+4 () Bool)
(declare-fun %lbl%+2 () Bool)
(declare-fun %lbl%+0 () Bool)
(declare-fun |b#0| () Int)
(declare-fun |a#0| () Int)
(declare-fun %lbl%@1 () Bool)
(declare-fun %lbl%+3 () Bool)
(declare-fun %lbl%+5 () Bool)
(assert (tickleBool true))
(assert (tickleBool false))
(assert (= (Ctor intType) 0))
(assert (= (Ctor realType) 1))
(assert (= (Ctor boolType) 2))
(assert (= (Ctor rmodeType) 3))
(assert (= (Ctor stringType) 4))
(assert (= (Ctor regexType) 5))
(assert (forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|)))
(assert (forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|)))
(assert (forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|)))
(assert (forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|)))
(assert (forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|)))
(assert (forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|)))
(assert (forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|)))
(assert (forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|)))
(assert (forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|)))
(assert (forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|)))
(assert (forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|)))
(assert (forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|)))
(assert (forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|)))
(assert (forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|)))
(assert (forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|)))
(assert (forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|)))
(assert (forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|)))
(assert (forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|)))
(assert (forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|)))
(assert (forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|)))
(assert (forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|)))
(assert (! %lbl%+6 :lblpos +6))
(assert (let ((a!1 (or %lbl%@1
               (= (+ |a#0| |b#0|) 21)
               (not (and (= |a#0| 10) (= |b#0| 11))))))
(let ((a!2 (or (not (and (= |a#0| 10) (= |b#0| 11)))
               (! a!1 :lblneg @1)
               (not (! %lbl%+0 :lblpos +0))
               (not (! %lbl%+3 :lblpos +3)))))
(let ((a!3 (and a!2
                (or (and (= |a#0| 10) (= |b#0| 11))
                    (! a!1 :lblneg @1)
                    (not (! %lbl%+0 :lblpos +0))
                    (not (! %lbl%+2 :lblpos +2))))))
(let ((a!4 (and (or (not (= |a#0| 10)) a!3 (not (! %lbl%+5 :lblpos +5)))
                (or (= |a#0| 10) a!3 (not (! %lbl%+4 :lblpos +4))))))
  (not a!4))))))

	(smt_solver check_sat_core)
(smt.simplifier-start)

before reduce
asserted formulas:
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
[HEAD] ==>
(! %lbl%+6 :lblpos +6)
(let ((a!1 (or %lbl%@1
               (= (+ |a#0| |b#0|) 21)
               (not (and (= |a#0| 10) (= |b#0| 11))))))
(let ((a!2 (or (not (and (= |a#0| 10) (= |b#0| 11)))
               (! a!1 :lblneg @1)
               (not (! %lbl%+0 :lblpos +0))
               (not (! %lbl%+3 :lblpos +3)))))
(let ((a!3 (and a!2
                (or (and (= |a#0| 10) (= |b#0| 11))
                    (! a!1 :lblneg @1)
                    (not (! %lbl%+0 :lblpos +0))
                    (not (! %lbl%+2 :lblpos +2))))))
(let ((a!4 (and (or (not (= |a#0| 10)) a!3 (not (! %lbl%+5 :lblpos +5)))
                (or (= |a#0| 10) a!3 (not (! %lbl%+4 :lblpos +4))))))
  (not a!4)))))
inconsistent: 0

(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.refine-injectivity)
(smt.pattern-inference)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)

after reduce
asserted formulas:
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
[HEAD] ==>
%lbl%+6
(! true :lblpos +6)
(or (not (= |a#0| 10)) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (not (= |a#0| 10)) a!1 a!3)))
(or (not (= |a#0| 10)) %lbl%+5)
(or (not (= |a#0| 10)) (! true :lblpos +5))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (= |a#0| 10))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (or a!1 a!3) (or a!1 a!3))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 %lbl%+5)))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (! true :lblpos +5))))
(or %lbl%+4 (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or %lbl%+4 a!1 a!3)))
(or %lbl%+4 %lbl%+5)
(or %lbl%+4 (! true :lblpos +5))
(or (! true :lblpos +4) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (! true :lblpos +4) a!1 a!3)))
(or (! true :lblpos +4) %lbl%+5)
(or (! true :lblpos +4) (! true :lblpos +5))
inconsistent: 0

after internalize_assertions()...
Logical context:
scope-lvl: 1
base-lvl:  1
search-lvl:  1
inconsistent(): 0
m_asserted_formulas.inconsistent(): 0
#1 := true
#23 := (tickleBool true)
#2 := false
#24 := (tickleBool false)
#28 := 0
#26 := intType
#27 := (Ctor intType)
#29 := (= #27 0)
#32 := 1
#30 := realType
#31 := (Ctor realType)
#33 := (= #31 1)
#37 := 2
#35 := boolType
#36 := (Ctor boolType)
#38 := (= #36 2)
#42 := 3
#40 := rmodeType
#41 := (Ctor rmodeType)
#43 := (= #41 3)
#47 := 4
#45 := stringType
#46 := (Ctor stringType)
#48 := (= #46 4)
#52 := 5
#50 := regexType
#51 := (Ctor regexType)
#53 := (= #51 5)
#55 := (:var 0 Int)
#56 := (int_2_U #55)
#59 := (pattern #56)
#57 := (U_2_int #56)
#58 := (= #57 #55)
#60 := (forall (vars (arg0 Int)) (:pat #59) #58)
#62 := (:var 0 T@U)
#65 := (U_2_int #62)
#69 := (pattern #65)
#66 := (int_2_U #65)
#67 := (= #66 #62)
#63 := (type #62)
#64 := (= #63 intType)
#170 := (not #64)
#171 := (or #170 #67)
#172 := (forall (vars (x T@U)) (:pat #69) #171)
#72 := (type #56)
#73 := (= #72 intType)
#74 := (forall (vars (arg0@@0 Int)) (:pat #59) #73)
#7 := (:var 0 Real)
#76 := (real_2_U #7)
#79 := (pattern #76)
#77 := (U_2_real #76)
#78 := (= #77 #7)
#80 := (forall (vars (arg0@@1 Real)) (:pat #79) #78)
#83 := (U_2_real #62)
#87 := (pattern #83)
#84 := (real_2_U #83)
#85 := (= #84 #62)
#82 := (= #63 realType)
#173 := (not #82)
#174 := (or #173 #85)
#175 := (forall (vars (x@@0 T@U)) (:pat #87) #174)
#90 := (type #76)
#91 := (= #90 realType)
#92 := (forall (vars (arg0@@2 Real)) (:pat #79) #91)
#94 := (:var 0 Bool)
#95 := (bool_2_U #94)
#98 := (pattern #95)
#96 := (U_2_bool #95)
#97 := (= #96 #94)
#99 := (forall (vars (arg0@@3 Bool)) (:pat #98) #97)
#102 := (U_2_bool #62)
#106 := (pattern #102)
#103 := (bool_2_U #102)
#104 := (= #103 #62)
#101 := (= #63 boolType)
#176 := (not #101)
#177 := (or #176 #104)
#178 := (forall (vars (x@@1 T@U)) (:pat #106) #177)
#109 := (type #95)
#110 := (= #109 boolType)
#111 := (forall (vars (arg0@@4 Bool)) (:pat #98) #110)
#113 := (:var 0 RoundingMode)
#114 := (rmode_2_U #113)
#117 := (pattern #114)
#115 := (U_2_rmode #114)
#116 := (= #115 #113)
#118 := (forall (vars (arg0@@5 RoundingMode)) (:pat #117) #116)
#121 := (U_2_rmode #62)
#125 := (pattern #121)
#122 := (rmode_2_U #121)
#123 := (= #122 #62)
#120 := (= #63 rmodeType)
#179 := (not #120)
#180 := (or #179 #123)
#181 := (forall (vars (x@@2 T@U)) (:pat #125) #180)
#128 := (type #114)
#129 := (= #128 rmodeType)
#130 := (forall (vars (arg0@@6 RoundingMode)) (:pat #117) #129)
#132 := (:var 0 String[bv[8]])
#133 := (string_2_U #132)
#136 := (pattern #133)
#134 := (U_2_string #133)
#135 := (= #134 #132)
#137 := (forall (vars (arg0@@7 String[bv[8]])) (:pat #136) #135)
#140 := (U_2_string #62)
#144 := (pattern #140)
#141 := (string_2_U #140)
#142 := (= #141 #62)
#139 := (= #63 stringType)
#182 := (not #139)
#183 := (or #182 #142)
#184 := (forall (vars (x@@3 T@U)) (:pat #144) #183)
#147 := (type #133)
#148 := (= #147 stringType)
#149 := (forall (vars (arg0@@8 String[bv[8]])) (:pat #136) #148)
#151 := (:var 0 RegEx[String[bv[8]]])
#152 := (regex_2_U #151)
#155 := (pattern #152)
#153 := (U_2_regex #152)
#154 := (= #153 #151)
#156 := (forall (vars (arg0@@9 RegEx[String[bv[8]]])) (:pat #155) #154)
#159 := (U_2_regex #62)
#163 := (pattern #159)
#160 := (regex_2_U #159)
#161 := (= #160 #62)
#158 := (= #63 regexType)
#185 := (not #158)
#186 := (or #185 #161)
#187 := (forall (vars (x@@4 T@U)) (:pat #163) #186)
#166 := (type #152)
#167 := (= #166 regexType)
#168 := (forall (vars (arg0@@10 RegEx[String[bv[8]]])) (:pat #155) #167)
#188 := (UOrdering2 #62 #62)
#217 := (pattern #188)
#220 := (forall (vars (x@@5 T@U)) (:pat #217) #188)
#191 := (:var 1 T@U)
#198 := (UOrdering2 #191 #62)
#190 := (:var 2 T@U)
#197 := (UOrdering2 #190 #191)
#203 := (pattern #197 #198)
#224 := (not #198)
#223 := (not #197)
#192 := (type #190)
#195 := (= #63 #192)
#222 := (not #195)
#193 := (type #191)
#194 := (= #193 #192)
#221 := (not #194)
#201 := (UOrdering2 #190 #62)
#226 := (or #201 #221 #222 #223 #224)
#225 := (forall (vars (x@@6 T@U) (y T@U) (z T@U)) (:pat #203) #226)
#210 := (UOrdering2 #62 #191)
#215 := (pattern #198 #210)
#227 := (not #210)
#209 := (= #63 #193)
#219 := (not #209)
#212 := (= #191 #62)
#230 := (or #212 #219 #224 #227)
#231 := (forall (vars (x@@7 T@U) (y@@0 T@U)) (:pat #215) #230)
#266 := %lbl%+6
#279 := lbl-lit[+6]
#228 := 10
#208 := a#0
#229 := (= a#0 10)
#207 := %lbl%@1
#237 := 21
#232 := b#0
#236 := (+ a#0 b#0)
#238 := (= #236 21)
#341 := (<= #236 21)
#309 := (>= #236 21)
#300 := lbl-lit[+3]
#249 := %lbl%+3
#233 := 11
#234 := (= b#0 11)
#273 := (<= b#0 11)
#287 := (>= b#0 11)
#296 := lbl-lit[@1]
#218 := %lbl%+0
#298 := lbl-lit[+0]
#306 := (not lbl-lit[+0])
#305 := (not %lbl%+0)
#304 := (not lbl-lit[@1])
#293 := (not #234)
#276 := (not %lbl%+3)
#275 := (not lbl-lit[+3])
#257 := (not #229)
#278 := (or %lbl%@1 #238 #257 #275 #276 #293 #304 #305 #306)
#243 := %lbl%+2
#303 := lbl-lit[+2]
#297 := (or #257 #293)
#299 := (not #297)
#282 := (not lbl-lit[+2])
#281 := (not %lbl%+2)
#280 := (or %lbl%@1 #238 #257 #281 #282 #293 #299 #304 #305 #306)
#284 := (not #280)
#274 := (not #278)
#285 := (or #274 #284)
#261 := %lbl%+5
#307 := lbl-lit[+5]
#254 := %lbl%+4
#310 := lbl-lit[+4]
#345 := (or #257 #229)
#346 := (or #257 #285)
#347 := (or #257 %lbl%+5)
#338 := (or #257 lbl-lit[+5])
#348 := (or #285 #229)
#349 := (or #285 #285)
#350 := (or #285 %lbl%+5)
#351 := (or #285 lbl-lit[+5])
#352 := (or %lbl%+4 #229)
#353 := (or %lbl%+4 #285)
#354 := (or %lbl%+4 %lbl%+5)
#355 := (or %lbl%+4 lbl-lit[+5])
#356 := (or lbl-lit[+4] #229)
#357 := (or lbl-lit[+4] #285)
#358 := (or lbl-lit[+4] %lbl%+5)
#359 := (or lbl-lit[+4] lbl-lit[+5])
asserted formulas:
#23 #24 #29 #33 #38 #43 #48 #53 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 #266 #279 #345 #346 #347 #338 #348 #349 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 
auxiliary clauses:
(not (= (+ |a#0| |b#0|) 21)) 
(<= (+ |a#0| |b#0|) 21) 

(not (= (+ |a#0| |b#0|) 21)) 
(>= (+ |a#0| |b#0|) 21) 

(= (+ |a#0| |b#0|) 21) 
(not (<= (+ |a#0| |b#0|) 21)) 
(not (>= (+ |a#0| |b#0|) 21)) 

(not (= |b#0| 11)) 
(<= |b#0| 11) 

(not (= |b#0| 11)) 
(>= |b#0| 11) 

(= |b#0| 11) 
(not (<= |b#0| 11)) 
(not (>= |b#0| 11)) 

(not %lbl%@1) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(not (= (+ |a#0| |b#0|) 21)) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(= |a#0| 10) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos +3) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

%lbl%+3 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(= |b#0| 11) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos @1) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

%lbl%+0 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos +0) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(not (= |a#0| 10)) 
%lbl%@1 
(= (+ |a#0| |b#0|) 21) 
(not (! true :lblpos +3)) 
(not %lbl%+3) 
(not (= |b#0| 11)) 
(not (! true :lblpos @1)) 
(not %lbl%+0) 
(not (! true :lblpos +0)) 
(not (or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0)))) 

(= |a#0| 10) 
(or (not (= |a#0| 10)) (not (= |b#0| 11))) 

(= |b#0| 11) 
(or (not (= |a#0| 10)) (not (= |b#0| 11))) 

(not (= |a#0| 10)) 
(not (= |b#0| 11)) 
(not (or (not (= |a#0| 10)) (not (= |b#0| 11)))) 

(not %lbl%@1) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(not (= (+ |a#0| |b#0|) 21)) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(= |a#0| 10) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

%lbl%+2 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos +2) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(= |b#0| 11) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(or (not (= |a#0| 10)) (not (= |b#0| 11))) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos @1) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

%lbl%+0 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos +0) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(not (= |a#0| 10)) 
%lbl%@1 
(= (+ |a#0| |b#0|) 21) 
(not (= |b#0| 11)) 
(not (! true :lblpos @1)) 
(not %lbl%+0) 
(not (! true :lblpos +0)) 
(not %lbl%+2) 
(not (! true :lblpos +2)) 
(not (or (not (= |a#0| 10)) (not (= |b#0| 11)))) 
(not (let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0))))) 

(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3))) 

(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3))) 

(not (or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0)))) 
(not (let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0))))) 
(not (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3)))) 

(not (= |a#0| 10)) 
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3))) 

(not (= |a#0| 10)) 
%lbl%+5 

(not (= |a#0| 10)) 
(! true :lblpos +5) 

(= |a#0| 10) 
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3))) 

(= |a#0| 10) 
%lbl%+4 

%lbl%+5 
%lbl%+4 

(! true :lblpos +5) 
%lbl%+4 

(= |a#0| 10) 
(! true :lblpos +4) 

%lbl%+5 
(! true :lblpos +4) 

(! true :lblpos +5) 
(! true :lblpos +4) 

current assignment:
#23: (tickleBool true)
#24: (tickleBool false)
#29: (= (Ctor intType) 0)
#33: (= (Ctor realType) 1)
#38: (= (Ctor boolType) 2)
#43: (= (Ctor rmodeType) 3)
#48: (= (Ctor stringType) 4)
#53: (= (Ctor regexType) 5)
#60: #60
#172: #172
#74: #74
#80: #80
#175: #175
#92: #92
#99: #99
#178: #178
#111: #111
#118: #118
#181: #181
#130: #130
#137: #137
#184: #184
#149: #149
#156: #156
#187: #187
#168: #168
#220: #220
#225: #225
#231: #231
#266: %lbl%+6
#279: lbl-lit[+6]
#285: (or (not (or %lbl%@1 #238 #257 #275 #276 #293 #304 #305 #306)) (not (or %lbl%@1 #238 #257 #281 #282 #293 #299 #304 #305 #306)))
equivalence classes:
#27 -> #28: (Ctor intType) -> 0
#31 -> #32: (Ctor realType) -> 1
#36 -> #37: (Ctor boolType) -> 2
#41 -> #42: (Ctor rmodeType) -> 3
#46 -> #47: (Ctor stringType) -> 4
#51 -> #52: (Ctor regexType) -> 5
case-splits:
[HEAD2]=> #345 #346 #347 #338 #348 #349 #285 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 
expression -> bool_var:
(#1 -> true) (#23 -> p1) (#24 -> p2) (#29 -> p3) (#33 -> p4) (#38 -> p5) (#43 -> p6) (#48 -> p7) (#53 -> p8) (#60 -> p9) (#172 -> p10) (#74 -> p11) (#80 -> p12) (#175 -> p13) (#92 -> p14) (#99 -> p15) (#178 -> p16) (#111 -> p17) (#118 -> p18) (#181 -> p19) (#130 -> p20) (#137 -> p21) (#184 -> p22) (#149 -> p23) (#156 -> p24) (#187 -> p25) (#168 -> p26) (#220 -> p27) (#225 -> p28) (#231 -> p29) (#266 -> p30) (#279 -> p31) (#229 -> p32) (#207 -> p33) (#238 -> p34) (#341 -> p35) (#309 -> p36) (#300 -> p37) (#249 -> p38) (#234 -> p39) (#273 -> p40) (#287 -> p41) (#296 -> p42) (#218 -> p43) (#298 -> p44) (#278 -> p45) (#243 -> p46) (#303 -> p47) (#297 -> p48) (#280 -> p49) (#285 -> p50) (#261 -> p51) (#307 -> p52) (#254 -> p53) (#310 -> p54) 
expression -> enode:
(#1 -> e!0) (#2 -> e!1) (#23 -> e!2) (#24 -> e!3) (#26 -> e!4) (#27 -> e!5) (#28 -> e!6) (#29 -> e!7) (#30 -> e!8) (#31 -> e!9) (#32 -> e!10) (#33 -> e!11) (#35 -> e!12) (#36 -> e!13) (#37 -> e!14) (#38 -> e!15) (#40 -> e!16) (#41 -> e!17) (#42 -> e!18) (#43 -> e!19) (#45 -> e!20) (#46 -> e!21) (#47 -> e!22) (#48 -> e!23) (#50 -> e!24) (#51 -> e!25) (#52 -> e!26) (#53 -> e!27) (#208 -> e!28) (#228 -> e!29) (#229 -> e!30) (#232 -> e!31) (#236 -> e!32) (#237 -> e!33) (#238 -> e!34) (#233 -> e!35) (#234 -> e!36) 
relevant exprs:
#23 #1 #24 #2 #29 #28 #27 #26 #33 #32 #31 #30 #38 #37 #36 #35 #43 #42 #41 #40 #48 #47 #46 #45 #53 #52 #51 #50 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 #266 #279 #345 #346 #347 #338 #348 #349 #285 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 
	Theory Display
5
Theory arithmetic:
vars:
infeasibles = 0 int_inf = 0
v0    #28   lo:         0, up:         0, value:          0, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 0
v1    #32   lo:         1, up:         1, value:          1, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 1
v2    #37   lo:         2, up:         2, value:          2, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 2
v3    #42   lo:         3, up:         3, value:          3, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 3
v4    #47   lo:         4, up:         4, value:          4, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 4
v5    #52   lo:         5, up:         5, value:          5, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 5
v6    #228  lo:        10, up:        10, value:         10, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: 10
v7    #208  lo:       -oo, up:        oo, value:       -715, occs:    1, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: a#0
v8    #232  lo:       -oo, up:        oo, value:       -550, occs:    1, atoms:    2, int , non-base  , shared: 0, unassigned: 2, rel: 0, def: b#0
v9    #236  lo:       -oo, up:        oo, value:      -1265, occs:    1, atoms:    2, int , base      , shared: 0, unassigned: 2, rel: 0, def: (+ a#0 b#0)
v10   #237  lo:        21, up:        21, value:         21, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: 21
v11   #233  lo:        11, up:        11, value:         11, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: 11
rows (compact view):
0 (v9) : -1*v7 + -1*v8 + v9
rows (expanded view):
0 (v9) : -1*a#0 + -1*b#0 + (+ a#0 b#0)
atoms:
v9   #236 <=     21    (+ a#0 b#0)
v9   #236 >=     21    (+ a#0 b#0)
v8   #232 <=     11    b#0
v8   #232 >=     11    b#0
asserted atoms:
8
7
6
9
recfun
disabled guards:

13
10
12
11
decl2enodes:
id 25 -> #236
id 138 -> #23 #24
id 139 -> #27 #31 #36 #41 #46 #51
hot bool vars:

(smt.preprocessing :time 0.21 :before-memory 2.37 :after-memory 2.37)
(smt.searching)
(smt.simplifying-clause-set :num-deleted-clauses 4)
(smt.simplifier-start)
(smt.simplifier-start)
(smt.stats :time 0.00 :before-memory 2.37 :after-memory 2.37)
unsat
(:reason-unknown "unknown")
(error "line 143 column 7: labels are not available")
(smt.simplifying :time 0.00 :before-memory 2.37 :after-memory 2.37)
(started "check-sat")
check_sat AST:

(and (tickleBool true) (tickleBool false))

(let ((a!1 (forall ((arg0 Int))
             (! (= (U_2_int (int_2_U arg0)) arg0)
                :pattern ((int_2_U arg0))
                :qid |typeInv:U_2_int|)))
      (a!2 (forall ((x T@U))
             (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
                :pattern ((U_2_int x))
                :qid |cast:U_2_int|)))
      (a!3 (forall ((arg0@@0 Int))
             (! (= (type (int_2_U arg0@@0)) intType)
                :pattern ((int_2_U arg0@@0))
                :qid |funType:int_2_U|)))
      (a!4 (forall ((arg0@@1 Real))
             (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
                :pattern ((real_2_U arg0@@1))
                :qid |typeInv:U_2_real|)))
      (a!5 (forall ((x@@0 T@U))
             (! (=> (= (type x@@0) realType)
                    (= (real_2_U (U_2_real x@@0)) x@@0))
                :pattern ((U_2_real x@@0))
                :qid |cast:U_2_real|)))
      (a!6 (forall ((arg0@@2 Real))
             (! (= (type (real_2_U arg0@@2)) realType)
                :pattern ((real_2_U arg0@@2))
                :qid |funType:real_2_U|)))
      (a!7 (forall ((arg0@@3 Bool))
             (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
                :pattern ((bool_2_U arg0@@3))
                :qid |typeInv:U_2_bool|)))
      (a!8 (forall ((x@@1 T@U))
             (! (=> (= (type x@@1) boolType)
                    (= (bool_2_U (U_2_bool x@@1)) x@@1))
                :pattern ((U_2_bool x@@1))
                :qid |cast:U_2_bool|)))
      (a!9 (forall ((arg0@@4 Bool))
             (! (= (type (bool_2_U arg0@@4)) boolType)
                :pattern ((bool_2_U arg0@@4))
                :qid |funType:bool_2_U|)))
      (a!10 (forall ((arg0@@5 RoundingMode))
              (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
                 :pattern ((rmode_2_U arg0@@5))
                 :qid |typeInv:U_2_rmode|)))
      (a!11 (forall ((x@@2 T@U))
              (! (=> (= (type x@@2) rmodeType)
                     (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
                 :pattern ((U_2_rmode x@@2))
                 :qid |cast:U_2_rmode|)))
      (a!12 (forall ((arg0@@6 RoundingMode))
              (! (= (type (rmode_2_U arg0@@6)) rmodeType)
                 :pattern ((rmode_2_U arg0@@6))
                 :qid |funType:rmode_2_U|)))
      (a!13 (forall ((arg0@@7 String))
              (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
                 :pattern ((string_2_U arg0@@7))
                 :qid |typeInv:U_2_string|)))
      (a!14 (forall ((x@@3 T@U))
              (! (=> (= (type x@@3) stringType)
                     (= (string_2_U (U_2_string x@@3)) x@@3))
                 :pattern ((U_2_string x@@3))
                 :qid |cast:U_2_string|)))
      (a!15 (forall ((arg0@@8 String))
              (! (= (type (string_2_U arg0@@8)) stringType)
                 :pattern ((string_2_U arg0@@8))
                 :qid |funType:string_2_U|)))
      (a!16 (forall ((arg0@@9 (RegEx String)))
              (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
                 :pattern ((regex_2_U arg0@@9))
                 :qid |typeInv:U_2_regex|)))
      (a!17 (forall ((x@@4 T@U))
              (! (=> (= (type x@@4) regexType)
                     (= (regex_2_U (U_2_regex x@@4)) x@@4))
                 :pattern ((U_2_regex x@@4))
                 :qid |cast:U_2_regex|)))
      (a!18 (forall ((arg0@@10 (RegEx String)))
              (! (= (type (regex_2_U arg0@@10)) regexType)
                 :pattern ((regex_2_U arg0@@10))
                 :qid |funType:regex_2_U|))))
  (and (= (Ctor intType) 0)
       (= (Ctor realType) 1)
       (= (Ctor boolType) 2)
       (= (Ctor rmodeType) 3)
       (= (Ctor stringType) 4)
       (= (Ctor regexType) 5)
       a!1
       a!2
       a!3
       a!4
       a!5
       a!6
       a!7
       a!8
       a!9
       a!10
       a!11
       a!12
       a!13
       a!14
       a!15
       a!16
       a!17
       a!18))

(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :no-pattern (U_2_int x@@5)
     :no-pattern (U_2_bool x@@5)
     :qid |bg:subtype-refl|))

(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (=> (and (= (type y) (type x@@6))
              (= (type z) (type x@@6))
              (UOrdering2 x@@6 y)
              (UOrdering2 y z))
         (UOrdering2 x@@6 z))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))

(forall ((x@@7 T@U) (y@@0 T@U))
  (! (=> (= (type y@@0) (type x@@7))
         (=> (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)) (= x@@7 y@@0)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))

(let ((a!1 (or %lbl%@1
               (=> (and (= |a#0| 10) (= |b#0| 11)) (= (+ |a#0| |b#0|) 21)))))
(let ((a!2 (=> (and (= |a#0| 10) (= |b#0| 11))
               (=> (! (and %lbl%+0 true) :lblpos +0) (! a!1 :lblneg @1))))
      (a!3 (=> (not (and (= |a#0| 10) (= |b#0| 11)))
               (=> (! (and %lbl%+0 true) :lblpos +0) (! a!1 :lblneg @1)))))
(let ((a!4 (and (=> (! (and %lbl%+3 true) :lblpos +3) a!2)
                (=> (! (and %lbl%+2 true) :lblpos +2) a!3))))
(let ((a!5 (=> (! (and %lbl%+4 true) :lblpos +4) (=> (not (= |a#0| 10)) a!4))))
(let ((a!6 (and (=> (! (and %lbl%+5 true) :lblpos +5) (=> (= |a#0| 10) a!4))
                a!5)))
  (not (=> (! (and %lbl%+6 true) :lblpos +6) a!6)))))))

%lbl%@1

	(call solver...)
(combined-solver "using solver 2 (without a timeout)")
	(solver_na2as check_sat_core)

solver check_sat_core
(declare-sort T@U 0)
(declare-sort T@T 0)
(declare-fun tickleBool (Bool) Bool)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun UOrdering2 (T@U T@U) Bool)
(declare-fun %lbl%+6 () Bool)
(declare-fun |a#0| () Int)
(declare-fun %lbl%+0 () Bool)
(declare-fun |b#0| () Int)
(declare-fun %lbl%+2 () Bool)
(declare-fun %lbl%@1 () Bool)
(declare-fun %lbl%+3 () Bool)
(declare-fun %lbl%+5 () Bool)
(declare-fun %lbl%+4 () Bool)
(assert (tickleBool true))
(assert (tickleBool false))
(assert (= (Ctor intType) 0))
(assert (= (Ctor realType) 1))
(assert (= (Ctor boolType) 2))
(assert (= (Ctor rmodeType) 3))
(assert (= (Ctor stringType) 4))
(assert (= (Ctor regexType) 5))
(assert (forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|)))
(assert (forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|)))
(assert (forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|)))
(assert (forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|)))
(assert (forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|)))
(assert (forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|)))
(assert (forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|)))
(assert (forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|)))
(assert (forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|)))
(assert (forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|)))
(assert (forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|)))
(assert (forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|)))
(assert (forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|)))
(assert (forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|)))
(assert (forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|)))
(assert (forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|)))
(assert (forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|)))
(assert (forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|)))
(assert (forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|)))
(assert (forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|)))
(assert (forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|)))
(assert %lbl%+6)
(assert (! true :lblpos +6))
(assert (or (not (= |a#0| 10)) (= |a#0| 10)))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (not (= |a#0| 10)) a!1 a!3))))
(assert (or (not (= |a#0| 10)) %lbl%+5))
(assert (or (not (= |a#0| 10)) (! true :lblpos +5)))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (= |a#0| 10)))))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (or a!1 a!3) (or a!1 a!3)))))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 %lbl%+5))))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (! true :lblpos +5)))))
(assert (or %lbl%+4 (= |a#0| 10)))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or %lbl%+4 a!1 a!3))))
(assert (or %lbl%+4 %lbl%+5))
(assert (or %lbl%+4 (! true :lblpos +5)))
(assert (or (! true :lblpos +4) (= |a#0| 10)))
(assert (let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (! true :lblpos +4) a!1 a!3))))
(assert (or (! true :lblpos +4) %lbl%+5))
(assert (or (! true :lblpos +4) (! true :lblpos +5)))
(assert %lbl%@1)

	(smt_solver check_sat_core)
(smt.simplifier-start)

before reduce
asserted formulas:
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
%lbl%+6
(! true :lblpos +6)
(or (not (= |a#0| 10)) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (not (= |a#0| 10)) a!1 a!3)))
(or (not (= |a#0| 10)) %lbl%+5)
(or (not (= |a#0| 10)) (! true :lblpos +5))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (= |a#0| 10))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (or a!1 a!3) (or a!1 a!3))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 %lbl%+5)))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (! true :lblpos +5))))
(or %lbl%+4 (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or %lbl%+4 a!1 a!3)))
(or %lbl%+4 %lbl%+5)
(or %lbl%+4 (! true :lblpos +5))
(or (! true :lblpos +4) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (! true :lblpos +4) a!1 a!3)))
(or (! true :lblpos +4) %lbl%+5)
(or (! true :lblpos +4) (! true :lblpos +5))
[HEAD] ==>
%lbl%@1
inconsistent: 0

(smt.propagate-values)
(smt.nnf-cnf)
(smt.reduce-asserted)
(smt.refine-injectivity)
(smt.pattern-inference)
(smt.maximizing-bv-sharing)
(smt.reduce-asserted)
(smt.flatten-clauses)
(smt.simplifier-done)

after reduce
asserted formulas:
(tickleBool true)
(tickleBool false)
(= (Ctor intType) 0)
(= (Ctor realType) 1)
(= (Ctor boolType) 2)
(= (Ctor rmodeType) 3)
(= (Ctor stringType) 4)
(= (Ctor regexType) 5)
(forall ((arg0 Int))
  (! (= (U_2_int (int_2_U arg0)) arg0)
     :pattern ((int_2_U arg0))
     :qid |typeInv:U_2_int|))
(forall ((x T@U))
  (! (or (not (= (type x) intType)) (= (int_2_U (U_2_int x)) x))
     :pattern ((U_2_int x))
     :qid |cast:U_2_int|))
(forall ((arg0@@0 Int))
  (! (= (type (int_2_U arg0@@0)) intType)
     :pattern ((int_2_U arg0@@0))
     :qid |funType:int_2_U|))
(forall ((arg0@@1 Real))
  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
     :pattern ((real_2_U arg0@@1))
     :qid |typeInv:U_2_real|))
(forall ((x@@0 T@U))
  (! (or (not (= (type x@@0) realType)) (= (real_2_U (U_2_real x@@0)) x@@0))
     :pattern ((U_2_real x@@0))
     :qid |cast:U_2_real|))
(forall ((arg0@@2 Real))
  (! (= (type (real_2_U arg0@@2)) realType)
     :pattern ((real_2_U arg0@@2))
     :qid |funType:real_2_U|))
(forall ((arg0@@3 Bool))
  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
     :pattern ((bool_2_U arg0@@3))
     :qid |typeInv:U_2_bool|))
(forall ((x@@1 T@U))
  (! (or (not (= (type x@@1) boolType)) (= (bool_2_U (U_2_bool x@@1)) x@@1))
     :pattern ((U_2_bool x@@1))
     :qid |cast:U_2_bool|))
(forall ((arg0@@4 Bool))
  (! (= (type (bool_2_U arg0@@4)) boolType)
     :pattern ((bool_2_U arg0@@4))
     :qid |funType:bool_2_U|))
(forall ((arg0@@5 RoundingMode))
  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
     :pattern ((rmode_2_U arg0@@5))
     :qid |typeInv:U_2_rmode|))
(forall ((x@@2 T@U))
  (! (or (not (= (type x@@2) rmodeType)) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
     :pattern ((U_2_rmode x@@2))
     :qid |cast:U_2_rmode|))
(forall ((arg0@@6 RoundingMode))
  (! (= (type (rmode_2_U arg0@@6)) rmodeType)
     :pattern ((rmode_2_U arg0@@6))
     :qid |funType:rmode_2_U|))
(forall ((arg0@@7 String))
  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
     :pattern ((string_2_U arg0@@7))
     :qid |typeInv:U_2_string|))
(forall ((x@@3 T@U))
  (! (or (not (= (type x@@3) stringType))
         (= (string_2_U (U_2_string x@@3)) x@@3))
     :pattern ((U_2_string x@@3))
     :qid |cast:U_2_string|))
(forall ((arg0@@8 String))
  (! (= (type (string_2_U arg0@@8)) stringType)
     :pattern ((string_2_U arg0@@8))
     :qid |funType:string_2_U|))
(forall ((arg0@@9 (RegEx String)))
  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
     :pattern ((regex_2_U arg0@@9))
     :qid |typeInv:U_2_regex|))
(forall ((x@@4 T@U))
  (! (or (not (= (type x@@4) regexType)) (= (regex_2_U (U_2_regex x@@4)) x@@4))
     :pattern ((U_2_regex x@@4))
     :qid |cast:U_2_regex|))
(forall ((arg0@@10 (RegEx String)))
  (! (= (type (regex_2_U arg0@@10)) regexType)
     :pattern ((regex_2_U arg0@@10))
     :qid |funType:regex_2_U|))
(forall ((x@@5 T@U))
  (! (UOrdering2 x@@5 x@@5)
     :pattern ((UOrdering2 x@@5 x@@5))
     :qid |bg:subtype-refl|))
(forall ((x@@6 T@U) (y T@U) (z T@U))
  (! (or (UOrdering2 x@@6 z)
         (not (= (type y) (type x@@6)))
         (not (= (type z) (type x@@6)))
         (not (UOrdering2 x@@6 y))
         (not (UOrdering2 y z)))
     :pattern ((UOrdering2 x@@6 y) (UOrdering2 y z))
     :qid |bg:subtype-trans|))
(forall ((x@@7 T@U) (y@@0 T@U))
  (! (or (= x@@7 y@@0)
         (not (= (type y@@0) (type x@@7)))
         (not (UOrdering2 x@@7 y@@0))
         (not (UOrdering2 y@@0 x@@7)))
     :pattern ((UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
     :qid |bg:subtype-antisymm|))
%lbl%+6
(! true :lblpos +6)
(or (not (= |a#0| 10)) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (not (= |a#0| 10)) a!1 a!3)))
(or (not (= |a#0| 10)) %lbl%+5)
(or (not (= |a#0| 10)) (! true :lblpos +5))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (= |a#0| 10))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (or a!1 a!3) (or a!1 a!3))))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 %lbl%+5)))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or a!1 a!3 (! true :lblpos +5))))
(or %lbl%+4 (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or %lbl%+4 a!1 a!3)))
(or %lbl%+4 %lbl%+5)
(or %lbl%+4 (! true :lblpos +5))
(or (! true :lblpos +4) (= |a#0| 10))
(let ((a!1 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not (! true :lblpos +3))
                    (not %lbl%+3)
                    (not (= |b#0| 11))
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0)))))
      (a!2 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
(let ((a!3 (not (or %lbl%@1
                    (= (+ |a#0| |b#0|) 21)
                    (not (= |a#0| 10))
                    (not %lbl%+2)
                    (not (! true :lblpos +2))
                    (not (= |b#0| 11))
                    a!2
                    (not (! true :lblpos @1))
                    (not %lbl%+0)
                    (not (! true :lblpos +0))))))
  (or (! true :lblpos +4) a!1 a!3)))
(or (! true :lblpos +4) %lbl%+5)
(or (! true :lblpos +4) (! true :lblpos +5))
[HEAD] ==>
%lbl%@1
inconsistent: 0

after internalize_assertions()...
Logical context:
scope-lvl: 1
base-lvl:  1
search-lvl:  1
inconsistent(): 1
m_asserted_formulas.inconsistent(): 0
#1 := true
#23 := (tickleBool true)
#2 := false
#24 := (tickleBool false)
#28 := 0
#26 := intType
#27 := (Ctor intType)
#29 := (= #27 0)
#32 := 1
#30 := realType
#31 := (Ctor realType)
#33 := (= #31 1)
#37 := 2
#35 := boolType
#36 := (Ctor boolType)
#38 := (= #36 2)
#42 := 3
#40 := rmodeType
#41 := (Ctor rmodeType)
#43 := (= #41 3)
#47 := 4
#45 := stringType
#46 := (Ctor stringType)
#48 := (= #46 4)
#52 := 5
#50 := regexType
#51 := (Ctor regexType)
#53 := (= #51 5)
#55 := (:var 0 Int)
#56 := (int_2_U #55)
#59 := (pattern #56)
#57 := (U_2_int #56)
#58 := (= #57 #55)
#60 := (forall (vars (arg0 Int)) (:pat #59) #58)
#62 := (:var 0 T@U)
#65 := (U_2_int #62)
#69 := (pattern #65)
#66 := (int_2_U #65)
#67 := (= #66 #62)
#63 := (type #62)
#64 := (= #63 intType)
#170 := (not #64)
#171 := (or #170 #67)
#172 := (forall (vars (x T@U)) (:pat #69) #171)
#72 := (type #56)
#73 := (= #72 intType)
#74 := (forall (vars (arg0@@0 Int)) (:pat #59) #73)
#7 := (:var 0 Real)
#76 := (real_2_U #7)
#79 := (pattern #76)
#77 := (U_2_real #76)
#78 := (= #77 #7)
#80 := (forall (vars (arg0@@1 Real)) (:pat #79) #78)
#83 := (U_2_real #62)
#87 := (pattern #83)
#84 := (real_2_U #83)
#85 := (= #84 #62)
#82 := (= #63 realType)
#173 := (not #82)
#174 := (or #173 #85)
#175 := (forall (vars (x@@0 T@U)) (:pat #87) #174)
#90 := (type #76)
#91 := (= #90 realType)
#92 := (forall (vars (arg0@@2 Real)) (:pat #79) #91)
#94 := (:var 0 Bool)
#95 := (bool_2_U #94)
#98 := (pattern #95)
#96 := (U_2_bool #95)
#97 := (= #96 #94)
#99 := (forall (vars (arg0@@3 Bool)) (:pat #98) #97)
#102 := (U_2_bool #62)
#106 := (pattern #102)
#103 := (bool_2_U #102)
#104 := (= #103 #62)
#101 := (= #63 boolType)
#176 := (not #101)
#177 := (or #176 #104)
#178 := (forall (vars (x@@1 T@U)) (:pat #106) #177)
#109 := (type #95)
#110 := (= #109 boolType)
#111 := (forall (vars (arg0@@4 Bool)) (:pat #98) #110)
#113 := (:var 0 RoundingMode)
#114 := (rmode_2_U #113)
#117 := (pattern #114)
#115 := (U_2_rmode #114)
#116 := (= #115 #113)
#118 := (forall (vars (arg0@@5 RoundingMode)) (:pat #117) #116)
#121 := (U_2_rmode #62)
#125 := (pattern #121)
#122 := (rmode_2_U #121)
#123 := (= #122 #62)
#120 := (= #63 rmodeType)
#179 := (not #120)
#180 := (or #179 #123)
#181 := (forall (vars (x@@2 T@U)) (:pat #125) #180)
#128 := (type #114)
#129 := (= #128 rmodeType)
#130 := (forall (vars (arg0@@6 RoundingMode)) (:pat #117) #129)
#132 := (:var 0 String[bv[8]])
#133 := (string_2_U #132)
#136 := (pattern #133)
#134 := (U_2_string #133)
#135 := (= #134 #132)
#137 := (forall (vars (arg0@@7 String[bv[8]])) (:pat #136) #135)
#140 := (U_2_string #62)
#144 := (pattern #140)
#141 := (string_2_U #140)
#142 := (= #141 #62)
#139 := (= #63 stringType)
#182 := (not #139)
#183 := (or #182 #142)
#184 := (forall (vars (x@@3 T@U)) (:pat #144) #183)
#147 := (type #133)
#148 := (= #147 stringType)
#149 := (forall (vars (arg0@@8 String[bv[8]])) (:pat #136) #148)
#151 := (:var 0 RegEx[String[bv[8]]])
#152 := (regex_2_U #151)
#155 := (pattern #152)
#153 := (U_2_regex #152)
#154 := (= #153 #151)
#156 := (forall (vars (arg0@@9 RegEx[String[bv[8]]])) (:pat #155) #154)
#159 := (U_2_regex #62)
#163 := (pattern #159)
#160 := (regex_2_U #159)
#161 := (= #160 #62)
#158 := (= #63 regexType)
#185 := (not #158)
#186 := (or #185 #161)
#187 := (forall (vars (x@@4 T@U)) (:pat #163) #186)
#166 := (type #152)
#167 := (= #166 regexType)
#168 := (forall (vars (arg0@@10 RegEx[String[bv[8]]])) (:pat #155) #167)
#188 := (UOrdering2 #62 #62)
#217 := (pattern #188)
#220 := (forall (vars (x@@5 T@U)) (:pat #217) #188)
#191 := (:var 1 T@U)
#198 := (UOrdering2 #191 #62)
#190 := (:var 2 T@U)
#197 := (UOrdering2 #190 #191)
#203 := (pattern #197 #198)
#224 := (not #198)
#223 := (not #197)
#192 := (type #190)
#195 := (= #63 #192)
#222 := (not #195)
#193 := (type #191)
#194 := (= #193 #192)
#221 := (not #194)
#201 := (UOrdering2 #190 #62)
#226 := (or #201 #221 #222 #223 #224)
#225 := (forall (vars (x@@6 T@U) (y T@U) (z T@U)) (:pat #203) #226)
#210 := (UOrdering2 #62 #191)
#215 := (pattern #198 #210)
#227 := (not #210)
#209 := (= #63 #193)
#219 := (not #209)
#212 := (= #191 #62)
#230 := (or #212 #219 #224 #227)
#231 := (forall (vars (x@@7 T@U) (y@@0 T@U)) (:pat #215) #230)
#266 := %lbl%+6
#279 := lbl-lit[+6]
#228 := 10
#208 := a#0
#229 := (= a#0 10)
#207 := %lbl%@1
#237 := 21
#232 := b#0
#236 := (+ a#0 b#0)
#238 := (= #236 21)
#341 := (<= #236 21)
#309 := (>= #236 21)
#300 := lbl-lit[+3]
#249 := %lbl%+3
#233 := 11
#234 := (= b#0 11)
#273 := (<= b#0 11)
#287 := (>= b#0 11)
#296 := lbl-lit[@1]
#218 := %lbl%+0
#298 := lbl-lit[+0]
#306 := (not lbl-lit[+0])
#305 := (not %lbl%+0)
#304 := (not lbl-lit[@1])
#293 := (not #234)
#276 := (not %lbl%+3)
#275 := (not lbl-lit[+3])
#257 := (not #229)
#278 := (or %lbl%@1 #238 #257 #275 #276 #293 #304 #305 #306)
#243 := %lbl%+2
#303 := lbl-lit[+2]
#297 := (or #257 #293)
#299 := (not #297)
#282 := (not lbl-lit[+2])
#281 := (not %lbl%+2)
#280 := (or %lbl%@1 #238 #257 #281 #282 #293 #299 #304 #305 #306)
#284 := (not #280)
#274 := (not #278)
#285 := (or #274 #284)
#261 := %lbl%+5
#307 := lbl-lit[+5]
#254 := %lbl%+4
#310 := lbl-lit[+4]
#288 := (<= a#0 10)
#339 := (>= a#0 10)
#345 := (or #257 #229)
#346 := (or #257 #285)
#347 := (or #257 %lbl%+5)
#338 := (or #257 lbl-lit[+5])
#348 := (or #285 #229)
#349 := (or #285 #285)
#350 := (or #285 %lbl%+5)
#351 := (or #285 lbl-lit[+5])
#352 := (or %lbl%+4 #229)
#353 := (or %lbl%+4 #285)
#354 := (or %lbl%+4 %lbl%+5)
#355 := (or %lbl%+4 lbl-lit[+5])
#356 := (or lbl-lit[+4] #229)
#357 := (or lbl-lit[+4] #285)
#358 := (or lbl-lit[+4] %lbl%+5)
#359 := (or lbl-lit[+4] lbl-lit[+5])
asserted formulas:
#23 #24 #29 #33 #38 #43 #48 #53 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 #266 #279 #345 #346 #347 #338 #348 #349 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 #207 
auxiliary clauses:
(not (= (+ |a#0| |b#0|) 21)) 
(<= (+ |a#0| |b#0|) 21) 

(not (= (+ |a#0| |b#0|) 21)) 
(>= (+ |a#0| |b#0|) 21) 

(not (<= (+ |a#0| |b#0|) 21)) 
(not (>= (+ |a#0| |b#0|) 21)) 
(= (+ |a#0| |b#0|) 21) 

(<= |b#0| 11) 
(not (= |b#0| 11)) 

(>= |b#0| 11) 
(not (= |b#0| 11)) 

(= |b#0| 11) 
(not (<= |b#0| 11)) 
(not (>= |b#0| 11)) 

(not %lbl%@1) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(not (= (+ |a#0| |b#0|) 21)) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(= |a#0| 10) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos +3) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

%lbl%+3 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(= |b#0| 11) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos @1) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

%lbl%+0 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(! true :lblpos +0) 
(or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0))) 

(not (! true :lblpos +3)) 
(not %lbl%+3) 
(not (= |a#0| 10)) 
(not (or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0)))) 
(= (+ |a#0| |b#0|) 21) 
(not (= |b#0| 11)) 
(not (! true :lblpos @1)) 
(not %lbl%+0) 
(not (! true :lblpos +0)) 
%lbl%@1 

(= |a#0| 10) 
(or (not (= |a#0| 10)) (not (= |b#0| 11))) 

(= |b#0| 11) 
(or (not (= |a#0| 10)) (not (= |b#0| 11))) 

(not (or (not (= |a#0| 10)) (not (= |b#0| 11)))) 
(not (= |b#0| 11)) 
(not (= |a#0| 10)) 

(not %lbl%@1) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(not (= (+ |a#0| |b#0|) 21)) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(= |a#0| 10) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

%lbl%+2 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos +2) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(= |b#0| 11) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(or (not (= |a#0| 10)) (not (= |b#0| 11))) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos @1) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

%lbl%+0 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(! true :lblpos +0) 
(let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0)))) 

(not (let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0))))) 
(not (! true :lblpos +2)) 
(not (= |a#0| 10)) 
(not (= |b#0| 11)) 
(not (! true :lblpos @1)) 
(not %lbl%+0) 
(not (! true :lblpos +0)) 
%lbl%@1 
(= (+ |a#0| |b#0|) 21) 
(not (or (not (= |a#0| 10)) (not (= |b#0| 11)))) 
(not %lbl%+2) 

(not (let ((a!1 (not (or (not (= |a#0| 10)) (not (= |b#0| 11))))))
  (or %lbl%@1
      (= (+ |a#0| |b#0|) 21)
      (not (= |a#0| 10))
      (not %lbl%+2)
      (not (! true :lblpos +2))
      (not (= |b#0| 11))
      a!1
      (not (! true :lblpos @1))
      (not %lbl%+0)
      (not (! true :lblpos +0))))) 
(not (or %lbl%@1
    (= (+ |a#0| |b#0|) 21)
    (not (= |a#0| 10))
    (not (! true :lblpos +3))
    (not %lbl%+3)
    (not (= |b#0| 11))
    (not (! true :lblpos @1))
    (not %lbl%+0)
    (not (! true :lblpos +0)))) 

%lbl%+5 
(not (= |a#0| 10)) 

(! true :lblpos +5) 
(not (= |a#0| 10)) 

%lbl%+4 
(= |a#0| 10) 

%lbl%+5 
%lbl%+4 

(! true :lblpos +5) 
%lbl%+4 

(! true :lblpos +4) 
(= |a#0| 10) 

%lbl%+5 
(! true :lblpos +4) 

(! true :lblpos +5) 
(! true :lblpos +4) 

(<= |b#0| 11) 
(>= |b#0| 11) 

(<= (+ |a#0| |b#0|) 21) 
(>= (+ |a#0| |b#0|) 21) 

(<= |a#0| 10) 
(>= |a#0| 10) 

lemmas:
(>= (+ |a#0| |b#0|) 21) 
(not (>= |b#0| 11)) 
(not (>= |a#0| 10)) 

(<= (+ |a#0| |b#0|) 21) 
(not (<= |b#0| 11)) 
(not (<= |a#0| 10)) 

current assignment:
#23: (tickleBool true)
#24: (tickleBool false)
#29: (= (Ctor intType) 0)
#33: (= (Ctor realType) 1)
#38: (= (Ctor boolType) 2)
#43: (= (Ctor rmodeType) 3)
#48: (= (Ctor stringType) 4)
#53: (= (Ctor regexType) 5)
#60: #60
#172: #172
#74: #74
#80: #80
#175: #175
#92: #92
#99: #99
#178: #178
#111: #111
#118: #118
#181: #181
#130: #130
#137: #137
#184: #184
#149: #149
#156: #156
#187: #187
#168: #168
#220: #220
#225: #225
#231: #231
#266: %lbl%+6
#279: lbl-lit[+6]
#285: (or (not (or %lbl%@1 #238 #257 #275 #276 #293 #304 #305 #306)) (not (or %lbl%@1 #238 #257 #281 #282 #293 #299 #304 #305 #306)))
#229: (= a#0 10)
#261: %lbl%+5
#307: lbl-lit[+5]
#288: (<= a#0 10)
#339: (>= a#0 10)
#278: (or %lbl%@1 (= (+ a#0 b#0) 21) (not (= a#0 10)) (not lbl-lit[+3]) (not %lbl%+3) (not (= b#0 11)) (not lbl-lit[@1]) (not %lbl%+0) (not lbl-lit[+0]))
(not #280) n : (not (or %lbl%@1 (= (+ a#0 b#0) 21) (not (= a#0 10)) (not %lbl%+2) (not lbl-lit[+2]) (not (= b#0 11)) (not (or #257 #293)) (not lbl-lit[@1]) (not %lbl%+0) (not lbl-lit[+0])))
(not #207): (not %lbl%@1)
(not #238) n : (not (= (+ a#0 b#0) 21))
#243 n : %lbl%+2
#303 n : lbl-lit[+2]
#234 n : (= b#0 11)
#297 n : (or (not (= a#0 10)) (not (= b#0 11)))
#296 n : lbl-lit[@1]
#218 n : %lbl%+0
#298 n : lbl-lit[+0]
#273 n : (<= b#0 11)
#287 n : (>= b#0 11)
equivalence classes:
#27 -> #28: (Ctor intType) -> 0
#31 -> #32: (Ctor realType) -> 1
#36 -> #37: (Ctor boolType) -> 2
#41 -> #42: (Ctor rmodeType) -> 3
#46 -> #47: (Ctor stringType) -> 4
#51 -> #52: (Ctor regexType) -> 5
#208 -> #228: |a#0| -> 10
case-splits:
[HEAD1]=> #278 
#345 #346 #347 #338 #348 #349 [HEAD2]=> #285 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 
expression -> bool_var:
(#1 -> true) (#23 -> p1) (#24 -> p2) (#29 -> p3) (#33 -> p4) (#38 -> p5) (#43 -> p6) (#48 -> p7) (#53 -> p8) (#60 -> p9) (#172 -> p10) (#74 -> p11) (#80 -> p12) (#175 -> p13) (#92 -> p14) (#99 -> p15) (#178 -> p16) (#111 -> p17) (#118 -> p18) (#181 -> p19) (#130 -> p20) (#137 -> p21) (#184 -> p22) (#149 -> p23) (#156 -> p24) (#187 -> p25) (#168 -> p26) (#220 -> p27) (#225 -> p28) (#231 -> p29) (#266 -> p30) (#279 -> p31) (#229 -> p32) (#207 -> p33) (#238 -> p34) (#341 -> p35) (#309 -> p36) (#300 -> p37) (#249 -> p38) (#234 -> p39) (#273 -> p40) (#287 -> p41) (#296 -> p42) (#218 -> p43) (#298 -> p44) (#278 -> p45) (#243 -> p46) (#303 -> p47) (#297 -> p48) (#280 -> p49) (#285 -> p50) (#261 -> p51) (#307 -> p52) (#254 -> p53) (#310 -> p54) (#288 -> p55) (#339 -> p56) 
expression -> enode:
(#1 -> e!0) (#2 -> e!1) (#23 -> e!2) (#24 -> e!3) (#26 -> e!4) (#27 -> e!5) (#28 -> e!6) (#29 -> e!7) (#30 -> e!8) (#31 -> e!9) (#32 -> e!10) (#33 -> e!11) (#35 -> e!12) (#36 -> e!13) (#37 -> e!14) (#38 -> e!15) (#40 -> e!16) (#41 -> e!17) (#42 -> e!18) (#43 -> e!19) (#45 -> e!20) (#46 -> e!21) (#47 -> e!22) (#48 -> e!23) (#50 -> e!24) (#51 -> e!25) (#52 -> e!26) (#53 -> e!27) (#208 -> e!28) (#228 -> e!29) (#229 -> e!30) (#232 -> e!31) (#236 -> e!32) (#237 -> e!33) (#238 -> e!34) (#233 -> e!35) (#234 -> e!36) 
relevant exprs:
#23 #1 #24 #2 #29 #28 #27 #26 #33 #32 #31 #30 #38 #37 #36 #35 #43 #42 #41 #40 #48 #47 #46 #45 #53 #52 #51 #50 #60 #172 #74 #80 #175 #92 #99 #178 #111 #118 #181 #130 #137 #184 #149 #156 #187 #168 #220 #225 #231 #266 #279 #345 #346 #347 #338 #348 #349 #285 #350 #351 #352 #353 #354 #355 #356 #357 #358 #359 #229 #261 #307 #228 #208 #288 #339 #278 #207 
	Theory Display
5
Theory arithmetic:
vars:
infeasibles = 0 int_inf = 0
v0    #28   lo:         0, up:         0, value:          0, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 0
v1    #32   lo:         1, up:         1, value:          1, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 1
v2    #37   lo:         2, up:         2, value:          2, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 2
v3    #42   lo:         3, up:         3, value:          3, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 3
v4    #47   lo:         4, up:         4, value:          4, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 4
v5    #52   lo:         5, up:         5, value:          5, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 5
v6    #228  lo:        10, up:        10, value:         10, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: 10
v7    #208  lo:        10, up:        10, value:         10, occs:    1, atoms:    2, int , non-base  , shared: 0, unassigned: 0, rel: 1, def: a#0
v8    #232  lo:       -oo, up:        oo, value:         11, occs:    1, atoms:    2, int , non-base  , shared: 0, unassigned: 2, rel: 0, def: b#0
v9    #236  lo:       -oo, up:        oo, value:         21, occs:    1, atoms:    2, int , base      , shared: 0, unassigned: 2, rel: 0, def: (+ a#0 b#0)
v10   #237  lo:        21, up:        21, value:         21, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: 21
v11   #233  lo:        11, up:        11, value:         11, occs:    0, atoms:    0, int , non-base  , shared: 0, unassigned: 0, rel: 0, def: 11
rows (compact view):
0 (v9) : -1*v7:10 + -1*v8 + v9
rows (expanded view):
0 (v9) : -1*a#0 + -1*b#0 + (+ a#0 b#0)
atoms:
v9   #236 <=     21    (+ a#0 b#0)
v9   #236 >=     21    (+ a#0 b#0)
v8   #232 <=     11    b#0
v8   #232 >=     11    b#0
v7   #208 <=     10    a#0
v7   #208 >=     10    a#0
asserted atoms:
    v7   #208 <=     10    a#0
    v7   #208 >=     10    a#0
8
7
6
9
recfun
disabled guards:

13
10
12
11
decl2enodes:
id 25 -> #236
id 138 -> #23 #24
id 139 -> #27 #31 #36 #41 #46 #51
hot bool vars:

(smt.preprocessing :time 0.22 :before-memory 2.37 :after-memory 2.37)
unsat
